import numpy as np
import logging

import measurements.util.interpolate
import measurements.po4.wod.deviation.estimation

import util.math.interpolate

from .constants import INTERPOLATOR_SETUP


class Deviation_Model():
    
#     def __init__(self, measurements_file, separation_values, t_len, x_len, minimum_measurements=5, convert_spherical_to_cartesian=True, wrap_around_amount=1, number_of_linear_interpolators=1, total_overlapping_linear_interpolators=0, parallel=False):
    def __init__(self, measurements_file, separation_values, minimum_measurements=5, interpolator_setup=INTERPOLATOR_SETUP, parallel=True):
        
        from .constants import T_LEN, X_LEN, Y_LEN
        
        ## estimate deviation
        deviation = measurements.po4.wod.deviation.estimation.deviations_from_measurements(separation_values=separation_values, minimum_measurements=minimum_measurements, measurements_file=measurements_file)
        
        ## split deviation in points and values
        deviation_points = deviation[:, :-1]
        deviation_values = deviation[:, -1]
        
#         if convert_spherical_to_cartesian:
#             self.interpolator = measurements.util.interpolate.Time_Periodic_Earth_Interpolater(deviation_points, deviation_values, t_len, wrap_around_amount=wrap_around_amount, number_of_linear_interpolators=number_of_linear_interpolators, total_overlapping_linear_interpolators=total_overlapping_linear_interpolators, parallel=parallel)
#         else:
#             self.interpolator = measurements.util.interpolate.Time_Periodic_Non_Cartesian_Interpolator(deviation_points, deviation_values, t_len, x_len, wrap_around_amount=wrap_around_amount, number_of_linear_interpolators=number_of_linear_interpolators, total_overlapping_linear_interpolators=total_overlapping_linear_interpolators, parallel=parallel)
        
        z = separation_values[3]
        z_len = len(z)
        self.map_shape = (T_LEN, X_LEN, Y_LEN, z)
        
        deviation_points = measurements.util.interpolate.convert_coordinates_to_map_index(deviation_points, self.map_shape)
        
        ## prepare wrap_around_amount
        wrap_around_amount=interpolator_setup[0]
        try:
            wrap_around_amount = tuple(wrap_around_amount)
        except TypeError:
            wrap_around_amount = (wrap_around_amount,)
        if len(wrap_around_amount) == 1:
            ## use same wrap around for t and x
            wrap_around_amount = wrap_around_amount * 2
        if len(wrap_around_amount) == 2:
            ## append wrap around for y and z if missing
            wrap_around_amount = wrap_around_amount + (0,0)
        
        ## create interpolator
        self.interpolator = util.math.interpolate.Periodic_Interpolater(deviation_points, deviation_values, point_range_size=(T_LEN, X_LEN, Y_LEN, z_len), scaling_values=(X_LEN/T_LEN, None, None, None), wrap_around_amount=wrap_around_amount, number_of_linear_interpolators=interpolator_setup[1], total_overlapping_linear_interpolators=interpolator_setup[2], parallel=parallel)
    
    
    
    def deviation(self, interpolation_points):
        logging.debug('Interpolating standard deviation for {} points.'.format(len(interpolation_points)))
        
        interpolation_points = measurements.util.interpolate.convert_coordinates_to_map_index(interpolation_points, self.map_shape)
        
        ## interpolating
        deviation = self.interpolator.interpolate(interpolation_points)
        
        return deviation
